#include "avx.h"
#include <stdio.h>
#include <stdint.h>
#include <string.h>

// 打印128位向量的原始字节（小端顺序）
static void print_xmm_hex(__m128i xmm) {
    uint8_t buf[16];
    memcpy(buf, &xmm, 16);
    for(int i=0; i<16; i++) {
        printf("%02x ", buf[i]);
    }
    printf("\n");
}

// 打印256位向量的原始字节（小端顺序）
static void print_ymm_hex(__m256i ymm) {
    uint8_t buf[32];
    memcpy(buf, &ymm, 32);
    for(int i=0; i<32; i++) {
        printf("%02x ", buf[i]);
    }
    printf("\n");
}

// 打印128位向量（字节视图）
static void print_m128i_u8(const char* name, __m128i xmm) {
    uint8_t u8[16];
    memcpy(u8, &xmm, 16);
    printf("%s: [0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x]\n", 
           name, u8[0], u8[1], u8[2], u8[3], u8[4], u8[5], u8[6], u8[7],
           u8[8], u8[9], u8[10], u8[11], u8[12], u8[13], u8[14], u8[15]);
}

// 打印256位向量（字节视图）
static void print_m256i_u8(const char* name, __m256i ymm) {
    uint8_t u8[32];
    memcpy(u8, &ymm, 32);
    printf("%s: [0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x,\n"
           "      0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x,\n"
           "      0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x,\n"
           "      0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x]\n", 
           name, u8[0], u8[1], u8[2], u8[3], u8[4], u8[5], u8[6], u8[7],
           u8[8], u8[9], u8[10], u8[11], u8[12], u8[13], u8[14], u8[15],
           u8[16], u8[17], u8[18], u8[19], u8[20], u8[21], u8[22], u8[23],
           u8[24], u8[25], u8[26], u8[27], u8[28], u8[29], u8[30], u8[31]);
}

#define print_128 print_m128i_u8
#define print_256 print_m256i_u8
#define cmp_256 cmp_ymm
#define cmp_128 cmp_xmm
#define _mm128_load_si128 _mm_load_si128
#define _mm128_set1_epi32 _mm_set1_epi32

// 测试宏定义 - 128位立即数版本
#define TEST_VPSLLDQ_IMM_128(desc, shift_val, expected) do { \
    ALIGNED(32) uint8_t src_data[16] = { \
        0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, \
        0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10  \
    }; \
    __m128i src = _mm_load_si128((__m128i*)src_data); \
    __m128i dst; \
    \
    asm volatile ("vpslldq %1, %2, %0" : "=x"(dst) : "i"(shift_val), "x"(src)); \
    \
    print_128("  SRC     ", src); \
    printf("  imm     : %d\n", shift_val); \
    print_128("  Expected", expected); \
    print_128("  Actual  ", dst); \
    printf("  Expected (raw): "); \
    print_xmm_hex(expected); \
    printf("  Actual   (raw): "); \
    print_xmm_hex(dst); \
    \
    if (!cmp_128(dst, expected)) { \
        printf("  [FAIL] %s\n\n", desc); \
        ret = 1; \
    } else { \
        printf("  [PASS] %s\n\n", desc); \
    } \
} while(0)

// 测试宏定义 - 256位立即数版本
#define TEST_VPSLLDQ_IMM_256(desc, shift_val, expected) do { \
    ALIGNED(32) uint8_t src_data[32] = { \
        0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, \
        0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10, \
        0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, \
        0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20  \
    }; \
    __m256i src = _mm256_load_si256((__m256i*)src_data); \
    __m256i dst; \
    \
    asm volatile ("vpslldq %1, %2, %0" : "=x"(dst) : "i"(shift_val), "x"(src)); \
    \
    print_256("  SRC     ", src); \
    printf("  imm     : %d\n", shift_val); \
    print_256("  Expected", expected); \
    print_256("  Actual  ", dst); \
    printf("  Expected (raw): "); \
    print_ymm_hex(expected); \
    printf("  Actual   (raw): "); \
    print_ymm_hex(dst); \
    \
    if (!cmp_256(dst, expected)) { \
        printf("  [FAIL] %s\n\n", desc); \
        ret = 1; \
    } else { \
        printf("  [PASS] %s\n\n", desc); \
    } \
} while(0)

// 测试VPSLLDQ指令
int test_vpslldq() {
    int ret = 0;
    const char* test_name = "VPSLLDQ tests";
    
    printf("=== %s ===\n", test_name);
    
    // 128位测试 - 立即数
    TEST_VPSLLDQ_IMM_128("VPSLLDQ xmm, imm8=0", 0, 
                   _mm_setr_epi8(0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                                 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10));
    
    TEST_VPSLLDQ_IMM_128("VPSLLDQ xmm, imm8=4", 4, 
                   _mm_setr_epi8(0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03, 0x04,
                                 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C));
    
    TEST_VPSLLDQ_IMM_128("VPSLLDQ xmm, imm8=1", 1, 
                   _mm_setr_epi8(0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
                                 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F));
                
    // 256位测试 - 立即数
    TEST_VPSLLDQ_IMM_256("VPSLLDQ ymm, imm8=0", 0,
                   _mm256_setr_epi8(0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                                    0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10,
                                    0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18,
                                    0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20));
    
    TEST_VPSLLDQ_IMM_256("VPSLLDQ ymm, imm8=4", 4,
                   _mm256_setr_epi8(0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03, 0x04,
                                    0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C,
                                    0x00, 0x00, 0x00, 0x00, 0x11, 0x12, 0x13, 0x14,
                                    0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C));
    
    TEST_VPSLLDQ_IMM_256("VPSLLDQ ymm, imm8=8", 8,
                   _mm256_setr_epi8(0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                    0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18));
    
    // 边界测试 - 立即数
    TEST_VPSLLDQ_IMM_128("VPSLLDQ xmm, imm8=15", 15, 
                   _mm_setr_epi8(0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01));
    
    // 添加更多立即数边界测试
    TEST_VPSLLDQ_IMM_128("VPSLLDQ xmm, imm8=15", 15, 
                   _mm_setr_epi8(0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01));
    
    TEST_VPSLLDQ_IMM_128("VPSLLDQ xmm, imm8=16", 16, 
                   _mm_setr_epi8(0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00));
    
    TEST_VPSLLDQ_IMM_128("VPSLLDQ xmm, imm8=17", 17, 
                   _mm_setr_epi8(0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00));
    
    TEST_VPSLLDQ_IMM_256("VPSLLDQ ymm, imm8=31", 31,
                   _mm256_setr_epi8(0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00));
    
    TEST_VPSLLDQ_IMM_256("VPSLLDQ ymm, imm8=32", 32,
                   _mm256_setr_epi8(0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00));
    
    TEST_VPSLLDQ_IMM_256("VPSLLDQ ymm, imm8=33", 33,
                   _mm256_setr_epi8(0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00));
    
    TEST_VPSLLDQ_IMM_128("VPSLLDQ xmm, imm8=0", 0,
                   _mm_setr_epi8(0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                                 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10));
    
    TEST_VPSLLDQ_IMM_256("VPSLLDQ ymm, imm8=0", 0,
                   _mm256_setr_epi8(0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                                    0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10,
                                    0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18,
                                    0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20));
    
    printf("=== %s %s ===\n", test_name, ret ? "FAILED" : "PASSED");
    return ret;
}

int main() {
    return test_vpslldq();
}
